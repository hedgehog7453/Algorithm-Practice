# 数据结构分类
1. 数组 (Array)
2. 栈 (Stack)
3. 队列 (Queue)
4. 链表 (Linked list)
5. 树 (Tree)
6. 散列表 (Hash)
7. 堆 (Heap)
8. 图 (Graph)



## 数组
##### 特点

- 内存中连续存储多个元素的结构，在内存中的分配也是连续的
- 数组中的元素通过数组下标进行访问，数组下标从0开始
##### 优点
1. 按照索引查询元素速度快
2. 按照索引遍历数组方便
##### 缺点
1. 数组的大小固定后就无法扩容了，需要找新的连续内存
2. 数组只能存储一种类型的数据
3. 添加、删除的操作慢，因为要移动其他的元素
##### 适用场景
频繁查询、对存储空间要求不大、很少增加和删除的情况



## 链表
##### 特点

- 物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现
- 每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域
- 根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等
##### 优点
- 不需要初始化容量，可以任意加减元素；
- 添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加删除很快
##### 缺点
- 因为含有大量的指针域，占用空间较大
- 查找元素需要遍历链表来查找，非常耗时
##### 适用场景
数据量较小、需要频繁增加删除操作的场景



## 栈
##### 特点

- 一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作，**先进后出**
- 从栈顶放入元素的操作叫入栈，取出元素叫出栈
##### 适用场景
实现递归功能方面的场景，例如斐波那契数列



## 队列
##### 特点

- 与栈一样也是一种线性表，队列在一端添加元素，在另一端取出元素，也就是**先进先出**
- 从一端放入元素的操作称为入队，取出元素为出队
##### 适用场景
在多线程阻塞队列管理中非常适用



## 散列表
##### 特点

- 根据关键码和值 (key, value) 直接进行访问数据，通过key和value来映射到集合中的一个位置
- 记录的存储位置 = f(key)，f 成为散列函数，又称为哈希 (hash函数)
- 散列表就是把Key通过一个固定的算法函数即所谓的哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。
- 查找元素非常方便，然而因为哈希表是基于数组衍生的数据结构，添加删除元素比较慢



## 树
##### 特点

- 由大于0个有限节点组成一个具有层次关系的集合
- 每个节点有零个或多个子节点
- 没有父节点的节点称为根节点
- 每一个非根节点有且只有一个父节点
- 除了根节点外，每个子节点可以分为多个不相交的子树
### 二叉树
### 完美(Perfect)二叉树
- 深度为 *k* (>=-1) 且有 2^(*k*+1) - 1 个结点的二叉树（每层都是满的，也叫满二叉树）
### 完全(Complete)二叉树
- 根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐
### 完满(Full)二叉树
- 所有非叶子结点的度都是 2（只要你有孩子，你就必然是有两个孩子）
### 二叉搜索树

TODO

### 平衡二叉树

- 又被称为 AVL 树（有别于 AVL 算法），是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树
- 解决了二叉搜索树退化成链表的问题，把插入、查找、删除的时间复杂度最好情况和最坏情况都维持在 O(logN)。但是频繁旋转会使插入和删除牺牲掉 O(logN) 左右的时间，不过相对二叉查找树来说，时间上稳定了很多。

### 红黑树

TODO

### B+树

TODO



## 堆

##### 特点

- 堆可以被看做一棵完全二叉树的数组对象，满足下列性质：
  - 堆总是一棵完全二叉树
  - 堆中某个结点的值总是不大于或不小于其父结点的值
- 分为**大根堆/大顶堆/最大堆**和**小根堆/小顶堆/最小堆**
  - 在最大堆中，父节点的值比每一个子节点的值都要大，并且对堆中的每一个节点都成立
  - 在最小堆中，父节点的值比每一个子节点的值都要小，并且对堆中的每一个节点都成立
- 由于以上两种堆属性，堆常常被当做优先队列使用，因为可以快速地访问到“最重要”的元素
- 堆和普通树的区别
  - 节点的顺序。在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大，但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。
  - 内存占用。普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，不使用指针。
  - 平衡。二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到 O(logN)。你可以按任意顺序位置插入/删除数据，或者使用AVL树或者红黑树，但是在堆中实际上不需要整棵树都是有序的，我们只需要满足堆属性即可，所以在堆中平衡不是问题，因为堆中数据的组织方式可以保证 O(logN) 的性能。
  - 搜索。在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。
- 节点在数组中的位置i和它的父节点以及子节点的索引之间有一个映射关系，如果i是节点的索引，那么：
  - `parent(i) = floor((i - 1)/2)`
  - `left(i) = 2i + 1`
  - `right(i) = 2i + 2`
- 在最大堆中，父节点的值总是要大于等于其子节点的值，所以下面的公式对数组中任意一个索引i都成立：
  - `array[parent(i)] >= array[i]`
- 如果一个堆有n个节点，那么它的高度h是`floor(log2(n))`
- 如果最下面的一层已经填满，那么那一层包含`2^h`个节点，树中这一层以上所有的节点数目为`2^h-1`，所以整个堆中的节点数目为`2^(h+1)-1`。
##### 操作

- 两个原始操作用于保证插入或删除节点以后堆是一个有效的最大堆或者最小堆：
  - **`shiftUp()`**: 如果一个节点比它的父节点大（最大堆）或者小（最小堆），那么需要将它同父节点交换位置。这样是这个节点在数组的位置上升。
  - **`shiftDown()`**: 如果一个节点比它的子节点小（最大堆）或者大（最小堆），那么需要将它向下移动。这个操作也称作“堆化（heapify）”。
  - shiftUp 或者 shiftDown 是一个递归的过程，所以它的时间复杂度是 O(logN)
- 其他操作
  - **`insert(value)`**: 在堆的尾部添加一个新的元素，然后使用 shiftUp 来修复堆。O(logN)
  - **`remove()`**: 移除并返回最大值（最大堆）或者最小值（最小堆）。为了将这个节点删除后的空位填补上，需要将最后一个元素移到根节点的位置，然后使用 shiftDown 方法来修复堆。O(logN)
  - **`removeAtIndex(index)`**: 和 remove() 一样，差别在于可以移除堆中任意节点。当它与子节点比较位置不是无序时使用 shiftDown()，如果与父节点比较发现无序则使用 shiftUp()。O(logN)
  - **`replace(index, value)`**：将一个更小的值（最小堆）或者更大的值（最大堆）赋值给一个节点。由于这个操作破坏了堆属性，所以需要使用 shiftUp() 来修复堆属性。O(logN)
  - **`search(value)`**：用于给 replace() 和 removeAtIndex() 操作找到节点在数组中的索引。O(N)
  - **`buildHeap(array)`**：通过反复调用 insert() 方法将一个（无序）数组转换成一个堆。O(N)
  - **`peek()`**：不删除节点就返回最大值（最大堆）或者最小值（最小堆）。O(1)
- 堆排序：由于堆就是一个数组，我们可以使用它独特的属性将数组从低到高排序。时间复杂度：O(NlogN)。
  
## 图
##### 特点

- 图是一些**顶点/节点/交点**的集合，这些顶点通过一系列**边/链接**连接。树和链表都可以被当成是图

- 边可以有**权重（weight）**，可以有**方向**

- **单向图/有向无环图/Directed Acyclic Graph(DAG)** 是一种常见的图，这个图没有任何圈（无论你从哪一个节点出发，你都无法回到最初的节点），但是这个图有有向边

- 在代码中可以用**邻接列表**和**邻接矩阵**来描述图
  - **邻接列表**：每一个顶点会存储一个从它这里开始的边的列表。大多数使用邻接列表
  - **邻接矩阵**：行和列表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连、如果相连这个值表示的是相连边的权重。例如，如果从顶点A到顶点B有一条权重为 5.6 的边，那么矩阵中第A行第B列的位置的元素值应该是5.6。往这个图中添加顶点的成本非常昂贵，因为新的矩阵结果必须重新按照新的行/列创建，然后将已有的数据复制到新的矩阵中。

  ![avatar](/Users/jiayuli/Documents/Documents/Projects/Misc/data-structures/img/graph.png)

  假设 *V* 表示图中顶点的个数，*E* 表示边的个数。

| 操作       | 邻接列表 | 邻接矩阵 |
| ---------- | -------- | -------- |
| 存储空间   | O(V + E) | O(V^2)   |
| 添加顶点   | O(1)     | O(V^2)   |
| 添加边     | O(1)     | O(1)     |
| 检查相邻性 | O(V)     | O(1)     |



TBC



References:

https://www.cnblogs.com/idorax/p/6441043.html

https://www.jianshu.com/p/6b526aa481b1

https://www.jianshu.com/p/bce71b2bdbc8
